//! # ArXiv API response parsing
//!
//! This module provides a deserialization interface for the XML response generated by the [arXiv
//! API][api]. The main entry point is the [`Response`] struct.
//!
//! [api]: https://info.arxiv.org/help/api/user-manual.html
#[cfg(test)]
mod tests;

use std::{borrow::Cow, fmt};

use chrono::{DateTime, FixedOffset};
use serde::{
    Deserialize,
    de::{self, Deserializer, Visitor},
};

use crate::id::ArticleId;

/// A parsed arXiv API response.
///
/// For the simplest use-cases, parse into a [`Vec`] of [`Entry`]s.
/// ```
/// use rsxiv::{response::{Entry, Response}, id::ArticleId};
///
/// // abridged arXiv response obtained by querying
/// // `export.arxiv.org/api/query?id_list=2206.06921`
/// let xml = // r#"<feed xmlns...
#[doc = include_str!("response/tests/query_doc.txt")]
/// let response = Response::<Vec<Entry>>::from_xml(&xml).unwrap();
///
/// assert_eq!(response.entry.len(), 1);
/// assert_eq!(response.entry[0].id, ArticleId::parse("2206.06921v3").unwrap());
/// ```
///
/// ## Customizing deserialization
/// Deserialization is handled using the [`serde`] interface documented in [`quick_xml::de`].
///
/// The type parameter `T` is any container type of type `seq` in the [serde data
/// model](https://serde.rs/data-model.html) around a struct which can deserialize an `<entry>` in
/// the arXiv API response. The XML format of an entry is described in the
/// [entry metadata section of the arXiv API manual][api].
/// ```
/// use std::collections::BTreeSet;
///
/// use rsxiv::{response::{Entry, Response}, id::ArticleId};
/// use serde::Deserialize;
///
/// // abridged arXiv response obtained by querying
/// // `export.arxiv.org/api/query?search_query=cat:math.CA AND ti:diffuse`
/// let xml = // r#"<feed xmlns...
#[doc = include_str!("response/tests/query_doc_long.txt")]
///
/// // deserialize an entry, only keeping the title
/// #[derive(PartialEq, Eq, PartialOrd, Ord, Deserialize)]
/// struct EntryTitle {
///     title: String,
/// }
///
/// let response = Response::<BTreeSet<EntryTitle>>::from_xml(&xml).unwrap();
/// assert_eq!(response.entry.len(), 10);
/// assert_eq!(
///     response.entry.first().unwrap().title,
///     "A Note on the Axisymmetric Diffusion equation"
/// );
/// ```
///
/// [api]: https://info.arxiv.org/help/api/user-manual.html#332-entry-metadata
#[derive(Debug, Clone, PartialEq)]
pub struct Response<T> {
    /// When this query was last updated.
    pub updated: DateTime<FixedOffset>,
    /// Pagination information.
    pub pagination: Pagination,
    /// A container for the entries in the response.
    pub entry: T,
}

/// Pagination information for paged queries.
#[derive(Debug, Clone, PartialEq)]
pub struct Pagination {
    /// The total number of results matching the query.
    pub total_results: u64,
    /// The 0-based index corresponding to the first index in this response.
    pub start_index: u64,
    /// The maximum number of items per page.
    pub items_per_page: u64,
}

impl<'de, T: Default + Deserialize<'de>> Response<T> {
    /// Read a [`Response<T>`] from the raw XML response returned by the arXiv API.
    pub fn from_xml(xml: &'de str) -> Result<Self, quick_xml::DeError> {
        quick_xml::de::from_str::<Response<T>>(xml)
    }
}

impl<'de, T: Default + Deserialize<'de>> Deserialize<'de> for Response<T> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        // intermediate deserialization target
        #[derive(Deserialize)]
        pub struct RawResponse<T> {
            pub updated: DateTime<FixedOffset>,
            #[serde(rename = "totalResults")]
            pub total_results: u64,
            #[serde(rename = "startIndex")]
            pub start_index: u64,
            #[serde(rename = "itemsPerPage")]
            pub items_per_page: u64,
            #[serde(default)]
            pub entry: T,
        }
        let RawResponse {
            updated,
            total_results,
            start_index,
            items_per_page,
            entry,
        } = Deserialize::deserialize(deserializer)?;

        Ok(Response {
            updated,
            pagination: Pagination {
                total_results,
                start_index,
                items_per_page,
            },
            entry,
        })
    }
}

/// Typed representation of a single entry in the arXiv API response.
#[derive(Debug, Clone, PartialEq, Deserialize)]
pub struct Entry<'r> {
    /// The arXiv identifier of the entry.
    #[serde(deserialize_with = "deserialize_response_id")]
    pub id: ArticleId,
    /// The date that the retrieved version of the article was submitted.
    pub updated: DateTime<FixedOffset>,
    /// The date that `version 1` was submitted.
    pub published: DateTime<FixedOffset>,
    /// The title of the article.
    #[serde(borrow)]
    pub title: Cow<'r, str>,
    /// The article abstract.
    #[serde(borrow)]
    pub summary: Cow<'r, str>,
    /// The article authors.
    pub author: Vec<Author<'r>>,
    /// The author comment.
    #[serde(borrow)]
    pub comment: Option<Cow<'r, str>>,
    /// The arXiv or ACM or MSC category for an article.
    pub category: Vec<Category<'r>>,
    /// A journal reference.
    #[serde(borrow)]
    pub journal_ref: Option<Cow<'r, str>>,
    /// A url for the resolved DOI to an external resource.
    pub doi: Option<&'r str>,
}

/// A parsed category.
#[derive(Debug, Clone, PartialEq, Deserialize)]
pub struct Category<'r> {
    /// The category contents.
    #[serde(rename = "@term", borrow)]
    pub name: Cow<'r, str>,
}

/// An article author.
#[derive(Debug, Clone, PartialEq, Deserialize)]
pub struct Author<'r> {
    /// The name of the author.
    #[serde(borrow)]
    pub name: Cow<'r, str>,
    /// The affiliation of the author.
    #[serde(borrow)]
    pub affiliation: Option<Cow<'r, str>>,
}

/// A helper function to deserialize the `id` field of an entry, for use with the serde
/// [`deserialize_with`](https://serde.rs/field-attrs.html#deserialize_with) field attribute.
///
/// ### Examples
/// A deserialization target (for use with a [`Response`] struct) which only captures the article
/// identifier in each entry.
/// ```
/// use rsxiv::{response::deserialize_response_id, id::ArticleId};
/// use serde::Deserialize;
///
/// #[derive(Deserialize)]
/// struct EntryId {
///     #[serde(deserialize_with = "deserialize_response_id")]
///     id: ArticleId,
/// }
/// ```
pub fn deserialize_response_id<'de, D>(deserializer: D) -> Result<ArticleId, D::Error>
where
    D: Deserializer<'de>,
{
    struct IdVisitor;

    impl Visitor<'_> for IdVisitor {
        type Value = ArticleId;

        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            formatter.write_str("an arXiv identifier")
        }

        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
        where
            E: de::Error,
        {
            match v.strip_prefix("http://arxiv.org/abs/") {
                Some(id) => ArticleId::parse(id).map_err(de::Error::custom),
                None => Err(de::Error::custom(
                    "identifier missing expected prefix 'http://arxiv.org/abs/'",
                )),
            }
        }
    }

    deserializer.deserialize_str(IdVisitor)
}
